CCS PCM C Compiler, Version 5.007, 61971               20-Ara-22 16:18

               Filename:   C:\Users\alper\pi.lst

               ROM used:   509 words (6%)
                           Largest free fragment is 2048
               RAM used:   62 (17%) at main() level
                           65 (18%) worst case
               Stack used: 0 locations
               Stack size: 8

*
0000:  MOVLW  01
0001:  MOVWF  0A
0002:  GOTO   137
0003:  NOP
.................... #include<16F877.h> 
.................... //////// Standard Header file for the PIC16F877 device //////////////// 
.................... #device PIC16F877 
....................  
.................... #list 
....................  
.................... #include<stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
00B8:  MOVF   58,W
00B9:  MOVWF  7A
00BA:  MOVF   57,W
00BB:  MOVWF  04
00BC:  BCF    03.7
00BD:  BTFSC  7A.0
00BE:  BSF    03.7
00BF:  MOVF   00,W
00C0:  MOVWF  5B
00C1:  MOVF   5A,W
00C2:  MOVWF  7A
00C3:  MOVF   59,W
00C4:  MOVWF  04
00C5:  BCF    03.7
00C6:  BTFSC  7A.0
00C7:  BSF    03.7
00C8:  MOVF   00,W
00C9:  SUBWF  5B,W
00CA:  BTFSS  03.2
00CB:  GOTO   0E3
....................       if (*s1 == '\0') 
00CC:  MOVF   58,W
00CD:  MOVWF  7A
00CE:  MOVF   57,W
00CF:  MOVWF  04
00D0:  BCF    03.7
00D1:  BTFSC  7A.0
00D2:  BSF    03.7
00D3:  MOVF   00,F
00D4:  BTFSS  03.2
00D5:  GOTO   0D9
....................          return(0); 
00D6:  MOVLW  00
00D7:  MOVWF  78
00D8:  GOTO   0FB
00D9:  MOVF   58,W
00DA:  MOVWF  7A
00DB:  MOVF   57,W
00DC:  INCF   57,F
00DD:  BTFSC  03.2
00DE:  INCF   58,F
00DF:  INCF   59,F
00E0:  BTFSC  03.2
00E1:  INCF   5A,F
00E2:  GOTO   0B8
....................    return((*s1 < *s2) ? -1: 1); 
00E3:  MOVF   58,W
00E4:  MOVWF  7A
00E5:  MOVF   57,W
00E6:  MOVWF  04
00E7:  BCF    03.7
00E8:  BTFSC  58.0
00E9:  BSF    03.7
00EA:  MOVF   00,W
00EB:  MOVWF  5B
00EC:  MOVF   5A,W
00ED:  MOVWF  7A
00EE:  MOVF   59,W
00EF:  MOVWF  04
00F0:  BCF    03.7
00F1:  BTFSC  5A.0
00F2:  BSF    03.7
00F3:  MOVF   00,W
00F4:  SUBWF  5B,W
00F5:  BTFSC  03.0
00F6:  GOTO   0F9
00F7:  MOVLW  FF
00F8:  GOTO   0FA
00F9:  MOVLW  01
00FA:  MOVWF  78
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
013F:  BCF    03.5
0140:  CLRF   20
0141:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #FUSES XT,NOWDT,NOPROTECT,NOBROWNOUT,NOLVP,NOPUT,NOWRT,NOCPD 
.................... #bit led=0x05.0 
.................... #bit TRIS_led=0x85.0 
.................... #byte lcd=0x06 
.................... #byte TRIS_lcd=0x86 
.................... #bit rs=0x07.0 
.................... #bit TRIS_rs=0x87.0 
.................... #bit en=0x07.1 
.................... #bit TRIS_en=0x87.1 
.................... #bit relay=0x07.2 
.................... #bit TRIS_relay=0x87.2 
.................... #bit C1=0x08.0 
.................... #bit C2=0x08.1 
.................... #bit C3=0x08.2 
.................... #bit R1=0x08.3 
.................... #bit R2=0x08.4 
.................... #bit R3=0x08.5 
.................... #bit R4=0x08.6 
.................... #bit TRIS_C1=0x88.0 
.................... #bit TRIS_C2=0x88.1 
.................... #bit TRIS_C3=0x88.2 
.................... #bit TRIS_R1=0x88.3 
.................... #bit TRIS_R2=0x88.4 
.................... #bit TRIS_R3=0x88.5 
.................... #bit TRIS_R4=0x88.6 
.................... #use delay(clock=4000000) 
*
0087:  MOVLW  5A
0088:  MOVWF  04
0089:  BCF    03.7
008A:  MOVF   00,W
008B:  BTFSC  03.2
008C:  GOTO   09B
008D:  MOVLW  01
008E:  MOVWF  78
008F:  CLRF   77
0090:  DECFSZ 77,F
0091:  GOTO   090
0092:  DECFSZ 78,F
0093:  GOTO   08F
0094:  MOVLW  4A
0095:  MOVWF  77
0096:  DECFSZ 77,F
0097:  GOTO   096
0098:  GOTO   099
0099:  DECFSZ 00,F
009A:  GOTO   08D
009B:  RETURN
.................... void display(unsigned char a,int b);  //LCD  
.................... char keypad();                               //Keypad  
.................... void check();                                 //Parola kontrol rutini 
.................... char sifre[5]={"2580"};         //Önceden tanýmlanmýþ þifre 
*
0142:  MOVLW  32
0143:  MOVWF  22
0144:  MOVLW  35
0145:  MOVWF  23
0146:  MOVLW  38
0147:  MOVWF  24
0148:  MOVLW  30
0149:  MOVWF  25
014A:  CLRF   26
.................... char sfr[5]; 
.................... unsigned char acik_msg[15]="Sifreyi girin:"; 
014B:  MOVLW  53
014C:  MOVWF  2C
014D:  MOVLW  69
014E:  MOVWF  2D
014F:  MOVLW  66
0150:  MOVWF  2E
0151:  MOVLW  72
0152:  MOVWF  2F
0153:  MOVLW  65
0154:  MOVWF  30
0155:  MOVLW  79
0156:  MOVWF  31
0157:  MOVLW  69
0158:  MOVWF  32
0159:  MOVLW  20
015A:  MOVWF  33
015B:  MOVLW  67
015C:  MOVWF  34
015D:  MOVLW  69
015E:  MOVWF  35
015F:  MOVLW  72
0160:  MOVWF  36
0161:  MOVLW  69
0162:  MOVWF  37
0163:  MOVLW  6E
0164:  MOVWF  38
0165:  MOVLW  3A
0166:  MOVWF  39
0167:  CLRF   3A
.................... unsigned char dogru_msg[8]="HOSGELDÝNÝZ"; 
0168:  MOVLW  48
0169:  MOVWF  3B
016A:  MOVLW  4F
016B:  MOVWF  3C
016C:  MOVLW  53
016D:  MOVWF  3D
016E:  MOVLW  47
016F:  MOVWF  3E
0170:  MOVLW  45
0171:  MOVWF  3F
0172:  MOVLW  4C
0173:  MOVWF  40
0174:  MOVLW  44
0175:  MOVWF  41
0176:  MOVLW  DD
0177:  MOVWF  42
.................... unsigned char yanlis_msg[15]="YANLIS SÝFRE"; 
0178:  MOVLW  59
0179:  MOVWF  43
017A:  MOVLW  41
017B:  MOVWF  44
017C:  MOVLW  4E
017D:  MOVWF  45
017E:  MOVLW  4C
017F:  MOVWF  46
0180:  MOVLW  49
0181:  MOVWF  47
0182:  MOVLW  53
0183:  MOVWF  48
0184:  MOVLW  20
0185:  MOVWF  49
0186:  MOVLW  53
0187:  MOVWF  4A
0188:  MOVLW  DD
0189:  MOVWF  4B
018A:  MOVLW  46
018B:  MOVWF  4C
018C:  MOVLW  52
018D:  MOVWF  4D
018E:  MOVLW  45
018F:  MOVWF  4E
0190:  CLRF   4F
.................... char c; 
.................... int flag,i,count,j; 
.................... void main() 
*
0137:  BSF    03.5
0138:  BSF    1F.0
0139:  BSF    1F.1
013A:  BSF    1F.2
013B:  BCF    1F.3
013C:  BCF    03.7
013D:  MOVLW  1F
013E:  ANDWF  03,F
.................... { 
....................    TRIS_lcd=TRIS_en=TRIS_rs=TRIS_led=TRIS_relay=0; //Yol tarifi ayarlandý 
*
0191:  BSF    03.5
0192:  BCF    07.2
0193:  BCF    05.0
0194:  BCF    07.0
0195:  BCF    07.1
0196:  CLRF   06
....................    TRIS_R1=TRIS_R2=TRIS_R3=TRIS_R4=count=0; 
0197:  BCF    08.3
0198:  BCF    08.4
0199:  BCF    08.5
019A:  BCF    03.5
019B:  CLRF   55
019C:  BSF    03.5
019D:  BCF    08.6
019E:  BCF    03.5
019F:  BTFSS  55.0
01A0:  GOTO   1A4
01A1:  BSF    03.5
01A2:  BSF    08.6
01A3:  BCF    03.5
01A4:  BSF    03.5
01A5:  BTFSC  08.6
01A6:  BSF    08.5
01A7:  BTFSC  08.5
01A8:  BSF    08.4
01A9:  BTFSC  08.4
01AA:  BSF    08.3
....................    TRIS_C1=TRIS_C2=TRIS_C3=1; 
01AB:  BSF    08.2
01AC:  BSF    08.1
01AD:  BSF    08.0
....................     while(TRUE) 
....................     { 
....................      c=keypad(); 
01AE:  BCF    03.5
01AF:  GOTO   004
01B0:  MOVF   78,W
01B1:  MOVWF  52
....................      { 
....................      if(c=='*')                                    //Koþulu baþlat 
01B2:  MOVF   52,W
01B3:  SUBLW  2A
01B4:  BTFSS  03.2
01B5:  GOTO   1DE
....................      { 
....................      flag=1;                                       //Diðer anahtarlarý taramak için bayrak ayarlandý 
01B6:  MOVLW  01
01B7:  MOVWF  53
....................      count=0; 
01B8:  CLRF   55
....................      display(0x01,0); 
01B9:  MOVWF  58
01BA:  CLRF   59
01BB:  CALL   09C
....................      display(0x38,0); 
01BC:  MOVLW  38
01BD:  MOVWF  58
01BE:  CLRF   59
01BF:  CALL   09C
....................      display(0x0f,0); 
01C0:  MOVLW  0F
01C1:  MOVWF  58
01C2:  CLRF   59
01C3:  CALL   09C
....................      display(0x80,0); 
01C4:  MOVLW  80
01C5:  MOVWF  58
01C6:  CLRF   59
01C7:  CALL   09C
....................      for(i=0;i<=13;i++) 
01C8:  CLRF   54
01C9:  MOVF   54,W
01CA:  SUBLW  0D
01CB:  BTFSS  03.0
01CC:  GOTO   1D9
....................      { 
....................      display(acik_msg[i],1); 
01CD:  MOVLW  2C
01CE:  ADDWF  54,W
01CF:  MOVWF  04
01D0:  BCF    03.7
01D1:  MOVF   00,W
01D2:  MOVWF  57
01D3:  MOVWF  58
01D4:  MOVLW  01
01D5:  MOVWF  59
01D6:  CALL   09C
01D7:  INCF   54,F
01D8:  GOTO   1C9
....................      } 
....................      display(0xc0,0); 
01D9:  MOVLW  C0
01DA:  MOVWF  58
01DB:  CLRF   59
01DC:  CALL   09C
....................      } 
01DD:  GOTO   1FB
....................      else if(c=='#')                         //koþul kapatýlýyor 
01DE:  MOVF   52,W
01DF:  SUBLW  23
01E0:  BTFSS  03.2
01E1:  GOTO   1ED
....................      { 
....................      count=0; 
01E2:  CLRF   55
....................      relay=0; 
01E3:  BCF    07.2
....................      display(0x01,0); 
01E4:  MOVLW  01
01E5:  MOVWF  58
01E6:  CLRF   59
01E7:  CALL   09C
....................      display(0x0c,0); 
01E8:  MOVLW  0C
01E9:  MOVWF  58
01EA:  CLRF   59
01EB:  CALL   09C
....................      } 
01EC:  GOTO   1FB
....................      else 
....................      { 
....................      display('*',1); 
01ED:  MOVLW  2A
01EE:  MOVWF  58
01EF:  MOVLW  01
01F0:  MOVWF  59
01F1:  CALL   09C
....................      sfr[count]=c;                   //Giriþi yeni dizilerde depolamak 
01F2:  MOVLW  27
01F3:  ADDWF  55,W
01F4:  MOVWF  04
01F5:  BCF    03.7
01F6:  MOVF   52,W
01F7:  MOVWF  00
....................      count=count+1;  
01F8:  MOVLW  01
01F9:  ADDWF  55,F
....................      check();                              
01FA:  GOTO   0AB
....................      } 
....................      } 
01FB:  GOTO   1AF
....................    } 
.................... } 
.................... void display(unsigned char a,int b) 
01FC:  SLEEP
....................   { 
....................     lcd=a; 
*
009C:  MOVF   58,W
009D:  MOVWF  06
....................     rs=b; 
009E:  BTFSS  59.0
009F:  BCF    07.0
00A0:  BTFSC  59.0
00A1:  BSF    07.0
....................     en=1; 
00A2:  BSF    07.1
....................     delay_ms(10); 
00A3:  MOVLW  0A
00A4:  MOVWF  5A
00A5:  CALL   087
....................     en=0; 
00A6:  BCF    07.1
....................     delay_ms(10); 
00A7:  MOVLW  0A
00A8:  MOVWF  5A
00A9:  CALL   087
00AA:  RETURN
....................   } 
.................... char keypad()                        
....................  { 
....................   if(flag==0)                            //Baþlatma Bekleniyor 
*
0004:  MOVF   53,F
0005:  BTFSS  03.2
0006:  GOTO   01D
....................   { 
....................     while(TRUE) 
....................     { 
....................      R4=1;  
0007:  BSF    08.6
....................      R1=R2=R3=0; 
0008:  BCF    08.5
0009:  BCF    08.4
000A:  BCF    08.3
....................      if(C1==1) 
000B:  BTFSS  08.0
000C:  GOTO   013
....................       { 
....................         while(C1==1); 
000D:  BTFSC  08.0
000E:  GOTO   00D
....................         count=0; 
000F:  CLRF   55
....................         return '*'; 
0010:  MOVLW  2A
0011:  MOVWF  78
0012:  GOTO   084
....................       } 
....................      if(C3==1) 
0013:  BTFSS  08.2
0014:  GOTO   01B
....................       { 
....................         while(C3==1); 
0015:  BTFSC  08.2
0016:  GOTO   015
....................         count=0; 
0017:  CLRF   55
....................         return '#'; 
0018:  MOVLW  23
0019:  MOVWF  78
001A:  GOTO   084
....................       } 
001B:  GOTO   007
....................    } 
....................  } 
001C:  GOTO   084
.................... else if(flag==1) 
001D:  DECFSZ 53,W
001E:  GOTO   084
.................... { 
.................... while(TRUE)                      //Keypad okuma 
.................... { 
.................... R1=1; 
001F:  BSF    08.3
.................... R2=R3=R4=0; 
0020:  BCF    08.6
0021:  BCF    08.5
0022:  BCF    08.4
.................... if(C1==1) 
0023:  BTFSS  08.0
0024:  GOTO   02A
.................... { 
.................... while(C1==1); 
0025:  BTFSC  08.0
0026:  GOTO   025
.................... return '1'; 
0027:  MOVLW  31
0028:  MOVWF  78
0029:  GOTO   084
.................... } 
.................... if(C2==1) 
002A:  BTFSS  08.1
002B:  GOTO   031
.................... { 
.................... while(C2==1); 
002C:  BTFSC  08.1
002D:  GOTO   02C
.................... return '2'; 
002E:  MOVLW  32
002F:  MOVWF  78
0030:  GOTO   084
.................... } 
.................... if(C3==1) 
0031:  BTFSS  08.2
0032:  GOTO   038
.................... { 
.................... while(C3==1); 
0033:  BTFSC  08.2
0034:  GOTO   033
.................... return '3'; 
0035:  MOVLW  33
0036:  MOVWF  78
0037:  GOTO   084
.................... } 
.................... R2=1; 
0038:  BSF    08.4
.................... R1=R3=R4=0; 
0039:  BCF    08.6
003A:  BCF    08.5
003B:  BCF    08.3
.................... if(C1==1) 
003C:  BTFSS  08.0
003D:  GOTO   043
.................... { 
.................... while(C1==1); 
003E:  BTFSC  08.0
003F:  GOTO   03E
.................... return '4'; 
0040:  MOVLW  34
0041:  MOVWF  78
0042:  GOTO   084
.................... } 
.................... if(C2==1) 
0043:  BTFSS  08.1
0044:  GOTO   04A
.................... { 
.................... while(C2==1); 
0045:  BTFSC  08.1
0046:  GOTO   045
.................... return '5'; 
0047:  MOVLW  35
0048:  MOVWF  78
0049:  GOTO   084
.................... } 
.................... if(C3==1) 
004A:  BTFSS  08.2
004B:  GOTO   051
.................... { 
.................... while(C3==1); 
004C:  BTFSC  08.2
004D:  GOTO   04C
.................... return '6'; 
004E:  MOVLW  36
004F:  MOVWF  78
0050:  GOTO   084
.................... } 
.................... R3=1; 
0051:  BSF    08.5
.................... R1=R2=R4=0; 
0052:  BCF    08.6
0053:  BCF    08.4
0054:  BCF    08.3
.................... if(C1==1) 
0055:  BTFSS  08.0
0056:  GOTO   05C
.................... { 
.................... while(C1==1); 
0057:  BTFSC  08.0
0058:  GOTO   057
.................... return '7'; 
0059:  MOVLW  37
005A:  MOVWF  78
005B:  GOTO   084
.................... } 
.................... if(C2==1) 
005C:  BTFSS  08.1
005D:  GOTO   063
.................... { 
.................... while(C2==1); 
005E:  BTFSC  08.1
005F:  GOTO   05E
.................... return '8'; 
0060:  MOVLW  38
0061:  MOVWF  78
0062:  GOTO   084
.................... } 
.................... if(C3==1) 
0063:  BTFSS  08.2
0064:  GOTO   06A
.................... { 
.................... while(C3==1); 
0065:  BTFSC  08.2
0066:  GOTO   065
.................... return '9'; 
0067:  MOVLW  39
0068:  MOVWF  78
0069:  GOTO   084
.................... } 
.................... R4=1; 
006A:  BSF    08.6
.................... R1=R2=R3=0; 
006B:  BCF    08.5
006C:  BCF    08.4
006D:  BCF    08.3
.................... if(C1==1) 
006E:  BTFSS  08.0
006F:  GOTO   075
.................... { 
.................... while(C1==1); 
0070:  BTFSC  08.0
0071:  GOTO   070
.................... return '*'; 
0072:  MOVLW  2A
0073:  MOVWF  78
0074:  GOTO   084
.................... } 
.................... if(C2==1) 
0075:  BTFSS  08.1
0076:  GOTO   07C
.................... { 
.................... while(C2==1); 
0077:  BTFSC  08.1
0078:  GOTO   077
.................... return '0'; 
0079:  MOVLW  30
007A:  MOVWF  78
007B:  GOTO   084
.................... } 
.................... if(C3==1) 
007C:  BTFSS  08.2
007D:  GOTO   083
.................... { 
.................... while(C3==1); 
007E:  BTFSC  08.2
007F:  GOTO   07E
.................... return '#'; 
0080:  MOVLW  23
0081:  MOVWF  78
0082:  GOTO   084
.................... } 
0083:  GOTO   01F
.................... } 
.................... } 
0084:  BCF    0A.3
0085:  BCF    0A.4
0086:  GOTO   1B0 (RETURN)
.................... } 
.................... void check() 
.................... { 
.................... if(count>3)                 //Giriþ sayýsý 3'ü aþarsa karþýlaþtýrma yürütülür 
*
00AB:  MOVF   55,W
00AC:  SUBLW  03
00AD:  BTFSC  03.0
00AE:  GOTO   134
....................  { 
....................  flag=count=0; 
00AF:  CLRF   55
00B0:  MOVF   55,W
00B1:  MOVWF  53
....................  j=strcmp(sfr,sifre);     //Girdi ve Önceden Tanýmlanmýþ þifrenin'nin karþýlaþtýrýlmasý 
00B2:  CLRF   58
00B3:  MOVLW  27
00B4:  MOVWF  57
00B5:  CLRF   5A
00B6:  MOVLW  22
00B7:  MOVWF  59
*
00FB:  MOVF   78,W
00FC:  MOVWF  56
....................  if(j==1) 
00FD:  DECFSZ 56,W
00FE:  GOTO   11A
....................    { 
....................       relay=1;                         //relay açýlýyor 
00FF:  BSF    07.2
....................       display(0x01,0); 
0100:  MOVLW  01
0101:  MOVWF  58
0102:  CLRF   59
0103:  CALL   09C
....................       display(0x80,0); 
0104:  MOVLW  80
0105:  MOVWF  58
0106:  CLRF   59
0107:  CALL   09C
....................       for(i=0;i<=6;i++) 
0108:  CLRF   54
0109:  MOVF   54,W
010A:  SUBLW  06
010B:  BTFSS  03.0
010C:  GOTO   119
....................       {display(dogru_msg[i],1);} 
010D:  MOVLW  3B
010E:  ADDWF  54,W
010F:  MOVWF  04
0110:  BCF    03.7
0111:  MOVF   00,W
0112:  MOVWF  57
0113:  MOVWF  58
0114:  MOVLW  01
0115:  MOVWF  59
0116:  CALL   09C
0117:  INCF   54,F
0118:  GOTO   109
....................    } 
0119:  GOTO   134
....................  else 
....................    { 
....................       relay=0; 
011A:  BCF    07.2
....................       display(0x01,0); 
011B:  MOVLW  01
011C:  MOVWF  58
011D:  CLRF   59
011E:  CALL   09C
....................       display(0x80,0); 
011F:  MOVLW  80
0120:  MOVWF  58
0121:  CLRF   59
0122:  CALL   09C
....................       for(i=0;i<=13;i++) 
0123:  CLRF   54
0124:  MOVF   54,W
0125:  SUBLW  0D
0126:  BTFSS  03.0
0127:  GOTO   134
....................       {display(yanlis_msg[i],1);} 
0128:  MOVLW  43
0129:  ADDWF  54,W
012A:  MOVWF  04
012B:  BCF    03.7
012C:  MOVF   00,W
012D:  MOVWF  57
012E:  MOVWF  58
012F:  MOVLW  01
0130:  MOVWF  59
0131:  CALL   09C
0132:  INCF   54,F
0133:  GOTO   124
....................    } 
....................  } 
0134:  BCF    0A.3
0135:  BCF    0A.4
0136:  GOTO   1FB (RETURN)
.................... } 

Configuration Fuses:
   Word  1: 3F39   XT NOWDT NOPUT NOBROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
